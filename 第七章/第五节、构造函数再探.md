### 委托构造函数 （delegating constructor, `C++11`）

- 委托构造函数将自己的职责委托给了其他构造函数。
- `Sale_data(): Sale_data("", 0, 0) {}`
- 委托构造函数的函数体并不会被执行

### 默认构造函数
- 对于类似`vector<int> v();`这样既可以当成使用默认构造函数初始化的对象，也可以是一个函数的声明，编译器优先考虑是函数声明

### 隐式的类型转换

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。
- 编译器只会自动地执行`仅一步`类型转换。
- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

### 聚合类 （aggregate class）

- 满足以下所有条件：
  - 所有成员都是`public`的。
  - 没有定义任何构造函数。
  - 没有类内初始值。
  - 没有基类，也没有`virtual`函数。
- 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。

### 字面值常量类

- `constexpr`函数的参数和返回值必须是字面值。
- **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
- 数据成员都是字面值类型的聚合类是字面值常量类。
- 如果不是聚合类，则必须满足下面所有条件：
  - 数据成员都必须是字面值类型。
  - 类必须至少含有一个`constexpr`构造函数。
  - 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。
